"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utilities = require("../utilities");

var _Logger = _interopRequireDefault(require("../Logger"));

var _sqlFragmentFactories = require("../sqlFragmentFactories");

var _symbols = require("../symbols");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = _Logger.default.child({
  namespace: 'sql'
});
/* eslint-disable complexity */
// $FlowFixMe


const sql = (parts, ...values) => {
  let rawSql = '';
  const parameterValues = [];
  let index = 0;

  const appendSqlFragment = sqlFragment => {
    rawSql += sqlFragment.sql;
    parameterValues.push(...sqlFragment.values);
  };

  for (const part of parts) {
    const token = values[index++];
    rawSql += part;

    if (index >= parts.length) {
      continue;
    }

    if ((0, _utilities.isPrimitiveValueExpression)(token)) {
      rawSql += '$' + (parameterValues.length + 1);
      parameterValues.push(token);
    } else if (token && token.type === _symbols.SqlTokenSymbol) {
      // @see https://github.com/gajus/slonik/issues/36 regarding FlowFixMe use.
      // $FlowFixMe
      appendSqlFragment((0, _sqlFragmentFactories.createSqlSqlFragment)(token, parameterValues.length));
    } else if (token && token.type === _symbols.RawSqlTokenSymbol) {
      // $FlowFixMe
      appendSqlFragment((0, _sqlFragmentFactories.createRawSqlSqlFragment)(token, parameterValues.length));
    } else if (token && token.type === _symbols.IdentifierTokenSymbol) {
      // $FlowFixMe
      appendSqlFragment((0, _sqlFragmentFactories.createIdentifierSqlFragment)(token));
    } else if (token && token.type === _symbols.IdentifierListTokenSymbol) {
      // $FlowFixMe
      appendSqlFragment((0, _sqlFragmentFactories.createIdentifierListSqlFragment)(token));
    } else if (token && token.type === _symbols.ArrayTokenSymbol) {
      // $FlowFixMe
      appendSqlFragment((0, _sqlFragmentFactories.createArraySqlFragment)(token, parameterValues.length));
    } else if (token && token.type === _symbols.ValueListTokenSymbol) {
      // $FlowFixMe
      appendSqlFragment((0, _sqlFragmentFactories.createValueListSqlFragment)(token, parameterValues.length));
    } else if (token && token.type === _symbols.TupleTokenSymbol) {
      // $FlowFixMe
      appendSqlFragment((0, _sqlFragmentFactories.createTupleSqlFragment)(token, parameterValues.length));
    } else if (token && token.type === _symbols.TupleListTokenSymbol) {
      // $FlowFixMe
      appendSqlFragment((0, _sqlFragmentFactories.createTupleListSqlFragment)(token, parameterValues.length));
    } else if (token && token.type === _symbols.UnnestTokenSymbol) {
      // $FlowFixMe
      appendSqlFragment((0, _sqlFragmentFactories.createUnnestSqlFragment)(token, parameterValues.length));
    } else {
      log.error({
        constructedSql: rawSql,
        offendingToken: token
      }, 'unexpected value expression');
      throw new TypeError('Unexpected value expression.');
    }
  }

  const query = (0, _utilities.deepFreeze)({
    sql: rawSql,
    type: _symbols.SqlTokenSymbol,
    values: parameterValues
  });
  return query;
};

sql.identifier = names => {
  // @todo Replace `type` with a symbol once Flow adds symbol support
  // @see https://github.com/facebook/flow/issues/810
  return (0, _utilities.deepFreeze)({
    names,
    type: _symbols.IdentifierTokenSymbol
  });
};

sql.identifierList = identifiers => {
  return (0, _utilities.deepFreeze)({
    identifiers,
    type: _symbols.IdentifierListTokenSymbol
  });
};

sql.raw = (rawSql, values) => {
  return (0, _utilities.deepFreeze)({
    sql: rawSql,
    type: _symbols.RawSqlTokenSymbol,
    values: values || []
  });
};

sql.valueList = values => {
  return (0, _utilities.deepFreeze)({
    type: _symbols.ValueListTokenSymbol,
    values
  });
};

sql.array = (values, memberType) => {
  return (0, _utilities.deepFreeze)({
    memberType,
    type: _symbols.ArrayTokenSymbol,
    values
  });
};

sql.tuple = values => {
  return (0, _utilities.deepFreeze)({
    type: _symbols.TupleTokenSymbol,
    values
  });
};

sql.tupleList = tuples => {
  return (0, _utilities.deepFreeze)({
    tuples,
    type: _symbols.TupleListTokenSymbol
  });
};

sql.unnest = (tuples, columnTypes) => {
  return (0, _utilities.deepFreeze)({
    columnTypes,
    tuples,
    type: _symbols.UnnestTokenSymbol
  });
};

var _default = sql;
exports.default = _default;
//# sourceMappingURL=sql.js.map