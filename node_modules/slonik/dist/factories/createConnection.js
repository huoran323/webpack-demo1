"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _routines = require("../routines");

var _binders = require("../binders");

var _errors = require("../errors");

const createConnection = async (parentLog, pool, clientConfiguration, connectionType, connectionHandler, poolHandler, query = null) => {
  for (const interceptor of clientConfiguration.interceptors) {
    if (interceptor.beforePoolConnection) {
      const maybeNewPool = await interceptor.beforePoolConnection({
        log: parentLog,
        poolId: pool.slonik.poolId,
        query
      });

      if (maybeNewPool) {
        return poolHandler(maybeNewPool);
      }
    }
  }

  let connection;

  try {
    connection = await pool.connect();
  } catch (error) {
    throw new _errors.ConnectionError(error.message);
  }

  if (!connection.connection.slonik.typeParserSetupPromise) {
    connection.connection.slonik.typeParserSetupPromise = (0, _routines.setupTypeParsers)(connection, clientConfiguration.typeParsers);
  }

  await connection.connection.slonik.typeParserSetupPromise;
  const connectionId = connection.connection.slonik.connectionId;
  const connectionLog = parentLog.child({
    connectionId
  });
  const connectionContext = {
    connectionId,
    connectionType,
    log: connectionLog,
    poolId: pool.slonik.poolId
  };
  const boundConnection = (0, _binders.bindPoolConnection)(connectionLog, connection, clientConfiguration);

  try {
    for (const interceptor of clientConfiguration.interceptors) {
      if (interceptor.afterPoolConnection) {
        await interceptor.afterPoolConnection(connectionContext, boundConnection);
      }
    }
  } catch (error) {
    pool._remove(connection);

    throw error;
  }

  let result;

  try {
    result = await connectionHandler(connectionLog, connection, boundConnection, clientConfiguration);
  } catch (error) {
    pool._remove(connection);

    throw error;
  }

  try {
    for (const interceptor of clientConfiguration.interceptors) {
      if (interceptor.beforePoolConnectionRelease) {
        await interceptor.beforePoolConnectionRelease(connectionContext, boundConnection);
      }
    }
  } catch (error) {
    pool._remove(connection);

    throw error;
  }

  await connection.release();
  return result;
};

var _default = createConnection;
exports.default = _default;
//# sourceMappingURL=createConnection.js.map