{"version":3,"sources":["../../src/factories/createConnection.js"],"names":["createConnection","parentLog","pool","clientConfiguration","connectionType","connectionHandler","poolHandler","query","interceptor","interceptors","beforePoolConnection","maybeNewPool","log","poolId","slonik","connection","connect","error","ConnectionError","message","typeParserSetupPromise","typeParsers","connectionId","connectionLog","child","connectionContext","boundConnection","afterPoolConnection","_remove","result","beforePoolConnectionRelease","release"],"mappings":";;;;;;;AAaA;;AAGA;;AAGA;;AAaA,MAAMA,gBAAgB,GAAG,OACvBC,SADuB,EAEvBC,IAFuB,EAGvBC,mBAHuB,EAIvBC,cAJuB,EAKvBC,iBALuB,EAMvBC,WANuB,EAOvBC,KAAkD,GAAG,IAP9B,KAQpB;AACH,OAAK,MAAMC,WAAX,IAA0BL,mBAAmB,CAACM,YAA9C,EAA4D;AAC1D,QAAID,WAAW,CAACE,oBAAhB,EAAsC;AACpC,YAAMC,YAAY,GAAG,MAAMH,WAAW,CAACE,oBAAZ,CAAiC;AAC1DE,QAAAA,GAAG,EAAEX,SADqD;AAE1DY,QAAAA,MAAM,EAAEX,IAAI,CAACY,MAAL,CAAYD,MAFsC;AAG1DN,QAAAA;AAH0D,OAAjC,CAA3B;;AAMA,UAAII,YAAJ,EAAkB;AAChB,eAAOL,WAAW,CAACK,YAAD,CAAlB;AACD;AACF;AACF;;AAED,MAAII,UAAJ;;AAEA,MAAI;AACFA,IAAAA,UAAU,GAAG,MAAMb,IAAI,CAACc,OAAL,EAAnB;AACD,GAFD,CAEE,OAAOC,KAAP,EAAc;AACd,UAAM,IAAIC,uBAAJ,CAAoBD,KAAK,CAACE,OAA1B,CAAN;AACD;;AAED,MAAI,CAACJ,UAAU,CAACA,UAAX,CAAsBD,MAAtB,CAA6BM,sBAAlC,EAA0D;AACxDL,IAAAA,UAAU,CAACA,UAAX,CAAsBD,MAAtB,CAA6BM,sBAA7B,GAAsD,gCAAiBL,UAAjB,EAA6BZ,mBAAmB,CAACkB,WAAjD,CAAtD;AACD;;AAED,QAAMN,UAAU,CAACA,UAAX,CAAsBD,MAAtB,CAA6BM,sBAAnC;AAEA,QAAME,YAAY,GAAGP,UAAU,CAACA,UAAX,CAAsBD,MAAtB,CAA6BQ,YAAlD;AAEA,QAAMC,aAAa,GAAGtB,SAAS,CAACuB,KAAV,CAAgB;AACpCF,IAAAA;AADoC,GAAhB,CAAtB;AAIA,QAAMG,iBAAiB,GAAG;AACxBH,IAAAA,YADwB;AAExBlB,IAAAA,cAFwB;AAGxBQ,IAAAA,GAAG,EAAEW,aAHmB;AAIxBV,IAAAA,MAAM,EAAEX,IAAI,CAACY,MAAL,CAAYD;AAJI,GAA1B;AAOA,QAAMa,eAAe,GAAG,iCAAmBH,aAAnB,EAAkCR,UAAlC,EAA8CZ,mBAA9C,CAAxB;;AAEA,MAAI;AACF,SAAK,MAAMK,WAAX,IAA0BL,mBAAmB,CAACM,YAA9C,EAA4D;AAC1D,UAAID,WAAW,CAACmB,mBAAhB,EAAqC;AACnC,cAAMnB,WAAW,CAACmB,mBAAZ,CAAgCF,iBAAhC,EAAmDC,eAAnD,CAAN;AACD;AACF;AACF,GAND,CAME,OAAOT,KAAP,EAAc;AACdf,IAAAA,IAAI,CAAC0B,OAAL,CAAab,UAAb;;AAEA,UAAME,KAAN;AACD;;AAED,MAAIY,MAAJ;;AAEA,MAAI;AACFA,IAAAA,MAAM,GAAG,MAAMxB,iBAAiB,CAACkB,aAAD,EAAgBR,UAAhB,EAA4BW,eAA5B,EAA6CvB,mBAA7C,CAAhC;AACD,GAFD,CAEE,OAAOc,KAAP,EAAc;AACdf,IAAAA,IAAI,CAAC0B,OAAL,CAAab,UAAb;;AAEA,UAAME,KAAN;AACD;;AAED,MAAI;AACF,SAAK,MAAMT,WAAX,IAA0BL,mBAAmB,CAACM,YAA9C,EAA4D;AAC1D,UAAID,WAAW,CAACsB,2BAAhB,EAA6C;AAC3C,cAAMtB,WAAW,CAACsB,2BAAZ,CAAwCL,iBAAxC,EAA2DC,eAA3D,CAAN;AACD;AACF;AACF,GAND,CAME,OAAOT,KAAP,EAAc;AACdf,IAAAA,IAAI,CAAC0B,OAAL,CAAab,UAAb;;AAEA,UAAME,KAAN;AACD;;AAED,QAAMF,UAAU,CAACgB,OAAX,EAAN;AAEA,SAAOF,MAAP;AACD,CAzFD;;eA2Fe7B,gB","sourcesContent":["// @flow\n\nimport type {\n  MaybePromiseType,\n  ClientConfigurationType,\n  ConnectionTypeType,\n  DatabasePoolType,\n  DatabasePoolConnectionType,\n  InternalDatabaseConnectionType,\n  InternalDatabasePoolType,\n  LoggerType,\n  TaggedTemplateLiteralInvocationType\n} from '../types';\nimport {\n  setupTypeParsers\n} from '../routines';\nimport {\n  bindPoolConnection\n} from '../binders';\nimport {\n  ConnectionError\n} from '../errors';\n\ntype ConnectionHandlerType = (\n  connectionLog: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  boundConnection: DatabasePoolConnectionType,\n  clientConfiguration: ClientConfigurationType\n) => MaybePromiseType<*>;\n\ntype PoolHandlerType = (pool: DatabasePoolType) => Promise<*>;\n\nconst createConnection = async (\n  parentLog: LoggerType,\n  pool: InternalDatabasePoolType,\n  clientConfiguration: ClientConfigurationType,\n  connectionType: ConnectionTypeType,\n  connectionHandler: ConnectionHandlerType,\n  poolHandler: PoolHandlerType,\n  query?: TaggedTemplateLiteralInvocationType | null = null\n) => {\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.beforePoolConnection) {\n      const maybeNewPool = await interceptor.beforePoolConnection({\n        log: parentLog,\n        poolId: pool.slonik.poolId,\n        query\n      });\n\n      if (maybeNewPool) {\n        return poolHandler(maybeNewPool);\n      }\n    }\n  }\n\n  let connection: InternalDatabaseConnectionType;\n\n  try {\n    connection = await pool.connect();\n  } catch (error) {\n    throw new ConnectionError(error.message);\n  }\n\n  if (!connection.connection.slonik.typeParserSetupPromise) {\n    connection.connection.slonik.typeParserSetupPromise = setupTypeParsers(connection, clientConfiguration.typeParsers);\n  }\n\n  await connection.connection.slonik.typeParserSetupPromise;\n\n  const connectionId = connection.connection.slonik.connectionId;\n\n  const connectionLog = parentLog.child({\n    connectionId\n  });\n\n  const connectionContext = {\n    connectionId,\n    connectionType,\n    log: connectionLog,\n    poolId: pool.slonik.poolId\n  };\n\n  const boundConnection = bindPoolConnection(connectionLog, connection, clientConfiguration);\n\n  try {\n    for (const interceptor of clientConfiguration.interceptors) {\n      if (interceptor.afterPoolConnection) {\n        await interceptor.afterPoolConnection(connectionContext, boundConnection);\n      }\n    }\n  } catch (error) {\n    pool._remove(connection);\n\n    throw error;\n  }\n\n  let result;\n\n  try {\n    result = await connectionHandler(connectionLog, connection, boundConnection, clientConfiguration);\n  } catch (error) {\n    pool._remove(connection);\n\n    throw error;\n  }\n\n  try {\n    for (const interceptor of clientConfiguration.interceptors) {\n      if (interceptor.beforePoolConnectionRelease) {\n        await interceptor.beforePoolConnectionRelease(connectionContext, boundConnection);\n      }\n    }\n  } catch (error) {\n    pool._remove(connection);\n\n    throw error;\n  }\n\n  await connection.release();\n\n  return result;\n};\n\nexport default createConnection;\n"],"file":"createConnection.js"}