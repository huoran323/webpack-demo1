{"version":3,"sources":["../src/types.js"],"names":[],"mappings":";;AAUA","sourcesContent":["// @flow\n\n/* eslint-disable no-use-before-define, import/exports-last, flowtype/require-types-at-top */\n\nimport type {\n  Readable\n} from 'stream';\nimport type {\n  LoggerType\n} from 'roarr';\nimport {\n  ArrayTokenSymbol,\n  SqlTokenSymbol,\n  RawSqlTokenSymbol,\n  IdentifierTokenSymbol,\n  IdentifierListTokenSymbol,\n  ValueListTokenSymbol,\n  TupleTokenSymbol,\n  TupleListTokenSymbol,\n  UnnestTokenSymbol\n} from './symbols';\n\nexport type {\n  LoggerType\n};\n\nexport opaque type QueryIdType = string;\n\nexport type MaybePromiseType<T> = T | Promise<T>;\n\nexport type StreamHandlerType = (stream: Readable) => void;\n\nexport type ConnectionTypeType = 'EXPLICIT' | 'IMPLICIT_QUERY' | 'IMPLICIT_TRANSACTION';\n\nexport type FieldType = {|\n  +columnID: number,\n  +dataTypeID: number,\n  +dataTypeModifier: number,\n  +dataTypeSize: number,\n  +format: string,\n  +name: string,\n  +tableID: number\n|};\n\ntype NoticeType = {|\n  +code: string,\n  +length: number,\n  +message: string,\n  +name: string,\n  +severity: string,\n  +where: string\n|};\n\ntype QueryResultType<T> = {|\n  +command: 'DELETE' | 'INSERT' | 'SELECT' | 'UPDATE',\n  +fields: $ReadOnlyArray<FieldType>,\n  +notices: $ReadOnlyArray<NoticeType>,\n  +oid: number | null,\n  +rowAsArray: boolean,\n  +rowCount: number,\n  +rows: $ReadOnlyArray<T>\n|};\n\n// eslint-disable-next-line flowtype/no-weak-types\nexport type InternalDatabasePoolType = any;\n\n// eslint-disable-next-line flowtype/no-weak-types\nexport type InternalDatabaseConnectionType = any;\n\n/**\n * @property captureStackTrace Dictates whether to capture stack trace before executing query. Middlewares access stack trace through query execution context. (Default: true)\n * @property connectionTimeout: Timeout (in milliseconds) after which an error is raised if cannot cannot be established. (Default: 5000)\n * @property idleTimeout Timeout (in milliseconds) after which idle clients are closed. (Default: 5000)\n * @property interceptors An array of [Slonik interceptors](https://github.com/gajus/slonik#slonik-interceptors).\n * @property maximumPoolSize Do not allow more than this many connections. (Default: 10)\n * @property minimumPoolSize Add more server connections to pool if below this number. (Default: 1)\n * @property typeParsers An array of [Slonik type parsers](https://github.com/gajus/slonik#slonik-type-parsers).\n */\nexport type ClientUserConfigurationType = {|\n  +captureStackTrace?: boolean,\n  +connectionTimeout?: number,\n  +idleTimeout?: number,\n  +interceptors?: $ReadOnlyArray<InterceptorType>,\n  +maximumPoolSize?: number,\n  +minimumPoolSize?: number,\n  +typeParsers?: $ReadOnlyArray<TypeParserType>\n|};\n\nexport type ClientConfigurationType = {|\n  +captureStackTrace: boolean,\n  +connectionTimeout?: number,\n  +idleTimeout?: number,\n  +interceptors: $ReadOnlyArray<InterceptorType>,\n  +maximumPoolSize?: number,\n  +minimumPoolSize?: number,\n  +typeParsers: $ReadOnlyArray<TypeParserType>\n|};\n\ntype CommonQueryMethodsType = {|\n  +any: QueryAnyFunctionType,\n  +anyFirst: QueryAnyFirstFunctionType,\n  +many: QueryManyFunctionType,\n  +manyFirst: QueryManyFirstFunctionType,\n  +maybeOne: QueryMaybeOneFunctionType,\n  +maybeOneFirst: QueryMaybeOneFirstFunctionType,\n  +one: QueryOneFunctionType,\n  +oneFirst: QueryOneFirstFunctionType,\n  +query: QueryFunctionType\n|};\n\nexport type DatabaseTransactionConnectionType = {|\n  ...CommonQueryMethodsType,\n  +transaction: (handler: TransactionFunctionType) => Promise<*>\n|};\n\nexport type TransactionFunctionType = (connection: DatabaseTransactionConnectionType) => Promise<*>;\n\nexport type DatabasePoolConnectionType = {|\n  ...CommonQueryMethodsType,\n\n  +stream: (sql: TaggedTemplateLiteralInvocationType, streamHandler: StreamHandlerType) => Promise<null>,\n  +transaction: (handler: TransactionFunctionType) => Promise<*>\n|};\n\nexport type ConnectionRoutineType = (connection: DatabasePoolConnectionType) => Promise<*>;\n\nexport type DatabasePoolType = {|\n  ...CommonQueryMethodsType,\n  +connect: (connectionRoutine: ConnectionRoutineType) => Promise<*>,\n\n  // $FlowFixMe\n  +stream: (sql: TaggedTemplateLiteralInvocationType, streamHandler: StreamHandlerType) => Promise<null>,\n  +transaction: (handler: TransactionFunctionType) => Promise<*>\n|};\n\n/**\n * This appears to be the only sane way to have a generic database connection type\n * that can be refined, i.e. DatabaseConnectionType => DatabasePoolType.\n */\nexport type DatabaseConnectionType =\n  $Shape<{\n    ...DatabasePoolConnectionType,\n    ...DatabasePoolType\n  }>;\n\ntype QueryResultRowColumnType = string | number | null;\n\nexport type QueryResultRowType = {\n  +[key: string]: QueryResultRowColumnType\n};\n\nexport type QueryType = {|\n  +sql: string,\n  +values: $ReadOnlyArray<PrimitiveValueExpressionType>\n|};\n\nexport type SqlFragmentType = {|\n  +sql: string,\n  +values: $ReadOnlyArray<PrimitiveValueExpressionType>\n|};\n\n/**\n * @property name Value of \"pg_type\".\"typname\" (e.g. \"int8\", \"timestamp\", \"timestamptz\").\n */\nexport type TypeParserType = {|\n  +name: string,\n  +parse: (value: string) => *\n|};\n\n/**\n * @property log Instance of Roarr logger with bound connection context parameters.\n * @property poolId Unique connection pool ID.\n * @property query The query that is initiating the connection.\n */\nexport type PoolContextType = {|\n  +log: LoggerType,\n  +poolId: string,\n  +query: TaggedTemplateLiteralInvocationType | null\n|};\n\n/**\n * @property connectionId Unique connection ID.\n * @property log Instance of Roarr logger with bound connection context parameters.\n * @property poolId Unique connection pool ID.\n */\nexport type ConnectionContextType = {|\n  +connectionId: string,\n  +connectionType: ConnectionTypeType,\n  +log: LoggerType,\n  +poolId: string\n|};\n\ntype CallSiteType = {|\n  +columnNumber: number,\n  +fileName: string | null,\n  +lineNumber: number\n|};\n\n/**\n * @property queryInputTime `process.hrtime.bigint()` for when query was received.\n * @property connectionId Unique connection ID.\n * @property log Instance of Roarr logger with bound query context parameters.\n * @property originalQuery A copy of the query before `transformQuery` middleware.\n * @property poolId Unique connection pool ID.\n * @property queryId Unique query ID.\n * @property transactionId Unique transaction ID.\n */\nexport type QueryContextType = {|\n  +connectionId: string,\n  +log: LoggerType,\n  +originalQuery: QueryType,\n  +poolId: string,\n  +queryId: QueryIdType,\n  +stackTrace: $ReadOnlyArray<CallSiteType> | null,\n  +queryInputTime: number,\n  +transactionId?: string\n|};\n\nexport type PositionalParameterValuesType = $ReadOnlyArray<PrimitiveValueExpressionType>;\n\nexport type NamedParameterValuesType = {\n  [key: string]: PrimitiveValueExpressionType\n};\n\nexport type IdentifierTokenType = {|\n  +names: $ReadOnlyArray<string>,\n  +type: typeof IdentifierTokenSymbol\n|};\n\nexport type IdentifierListMemberType = $ReadOnlyArray<string> |\n  {|\n    +alias: string,\n    +identifier: $ReadOnlyArray<string>\n  |};\n\nexport type IdentifierListTokenType = {|\n  +identifiers: $ReadOnlyArray<IdentifierListMemberType>,\n  +type: typeof IdentifierListTokenSymbol\n|};\n\nexport type SqlSqlTokenType = {|\n  +sql: string,\n  +type: typeof SqlTokenSymbol,\n  +values: $ReadOnlyArray<PrimitiveValueExpressionType>\n|};\n\nexport type RawSqlTokenType = {|\n  +sql: string,\n  +type: typeof RawSqlTokenSymbol,\n  +values: PositionalParameterValuesType | NamedParameterValuesType\n|};\n\nexport type ValueListSqlTokenType = {|\n  +values: PositionalParameterValuesType,\n  +type: typeof ValueListTokenSymbol\n|};\n\nexport type ArraySqlTokenType = {|\n  +memberType: string,\n  +type: typeof ArrayTokenSymbol,\n  +values: PositionalParameterValuesType\n|};\n\nexport type TupleSqlTokenType = {|\n  +values: PositionalParameterValuesType,\n  +type: typeof TupleTokenSymbol\n|};\n\nexport type TupleListSqlTokenType = {|\n  +tuples: $ReadOnlyArray<PositionalParameterValuesType>,\n  +type: typeof TupleListTokenSymbol\n|};\n\nexport type UnnestSqlTokenType = {|\n  +columnTypes: $ReadOnlyArray<string>,\n  +tuples: $ReadOnlyArray<PositionalParameterValuesType>,\n  +type: typeof UnnestTokenSymbol\n|};\n\nexport type PrimitiveValueExpressionType = string | number | boolean | null;\n\nexport type ValueExpressionType =\n  ArraySqlTokenType |\n  PrimitiveValueExpressionType |\n  IdentifierTokenType |\n  IdentifierListTokenType |\n  RawSqlTokenType |\n  SqlSqlTokenType |\n  TupleListSqlTokenType |\n  TupleSqlTokenType |\n  UnnestSqlTokenType |\n  ValueListSqlTokenType;\n\nexport type TaggedTemplateLiteralInvocationType = {|\n  +sql: string,\n  +type: typeof SqlTokenSymbol,\n  +values: $ReadOnlyArray<PrimitiveValueExpressionType>\n|};\n\n/**\n * see https://twitter.com/kuizinas/status/914139352908943360\n */\nexport type SqlTaggedTemplateType = {|\n  // eslint-disable-next-line no-undef\n  [[call]]: (\n    parts: $ReadOnlyArray<string>,\n    ...values: $ReadOnlyArray<ValueExpressionType>\n  ) => SqlSqlTokenType,\n  array: (\n    values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n    memberType: string\n  ) => ArraySqlTokenType,\n  identifier: (\n    names: $ReadOnlyArray<string>\n  ) => IdentifierTokenType,\n  identifierList: (\n    identifiers: $ReadOnlyArray<IdentifierListMemberType>\n  ) => IdentifierListTokenType,\n  raw: (\n    rawSql: string,\n    values?: $ReadOnlyArray<PrimitiveValueExpressionType>\n  ) => RawSqlTokenType,\n  tuple: (\n    values: $ReadOnlyArray<PrimitiveValueExpressionType>\n  ) => TupleSqlTokenType,\n  tupleList: (\n    tuples: $ReadOnlyArray<$ReadOnlyArray<PrimitiveValueExpressionType>>\n  ) => TupleListSqlTokenType,\n  unnest: (\n\n    // Value might be $ReadOnlyArray<$ReadOnlyArray<PrimitiveValueExpressionType>>,\n    // or it can be infinitely nested array, e.g.\n    // https://github.com/gajus/slonik/issues/44\n    // eslint-disable-next-line flowtype/no-weak-types\n    tuples: $ReadOnlyArray<$ReadOnlyArray<any>>,\n    columnTypes: $ReadOnlyArray<string>\n  ) => UnnestSqlTokenType,\n  valueList: (\n    values: $ReadOnlyArray<PrimitiveValueExpressionType>\n  ) => ValueListSqlTokenType\n|};\n\nexport type InternalQueryMethodType<R> = (\n  log: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  clientConfiguration: ClientConfigurationType,\n  sql: string,\n  values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n  uid?: QueryIdType\n) => Promise<R>;\n\nexport type InternalQueryAnyFirstFunctionType = InternalQueryMethodType<$ReadOnlyArray<QueryResultRowColumnType>>;\nexport type InternalQueryAnyFunctionType = InternalQueryMethodType<$ReadOnlyArray<QueryResultRowType>>;\nexport type InternalQueryFunctionType<T: QueryResultRowType> = InternalQueryMethodType<QueryResultType<T>>;\nexport type InternalQueryManyFirstFunctionType = InternalQueryMethodType<$ReadOnlyArray<QueryResultRowColumnType>>;\nexport type InternalQueryManyFunctionType = InternalQueryMethodType<$ReadOnlyArray<QueryResultRowType>>;\nexport type InternalQueryMaybeOneFirstFunctionType = InternalQueryMethodType<QueryResultRowColumnType | null>;\nexport type InternalQueryMaybeOneFunctionType = InternalQueryMethodType<QueryResultRowType | null>;\nexport type InternalQueryOneFirstFunctionType = InternalQueryMethodType<QueryResultRowColumnType>;\nexport type InternalQueryOneFunctionType = InternalQueryMethodType<QueryResultRowType>;\n\nexport type InternalStreamFunctionType = (\n  log: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  clientConfiguration: ClientConfigurationType,\n  sql: string,\n  values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n  streamHandler: StreamHandlerType,\n  uid?: QueryIdType\n\n// eslint-disable-next-line flowtype/no-weak-types\n) => Promise<Object>;\n\nexport type InternalTransactionFunctionType = (\n  log: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  clientConfiguration: ClientConfigurationType,\n  handler: TransactionFunctionType\n) => Promise<*>;\n\nexport type InternalNestedTransactionFunctionType = (\n  log: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  clientConfiguration: ClientConfigurationType,\n  handler: TransactionFunctionType,\n  transactionDepth: number\n) => Promise<*>;\n\ntype QueryMethodType<R> = (\n  sql: TaggedTemplateLiteralInvocationType\n) => Promise<R>;\n\n// @todo Figure out a reasonable column type that user can specific further.\n// Using `QueryResultRowType` and `QueryResultRowColumnType` is not an option\n// because all cases where user specifies expected type cause an error, e.g.\n// `let fooId: number = await oneFirst()` would produce an error since\n// QueryResultRowColumnType type allows `string | number | null`.\n// Therefore, we can only safely assume the shape of the result, e.g. collection vs object.\n\n// eslint-disable-next-line flowtype/no-weak-types\ntype ExternalQueryResultRowColumnType = any;\n\n// eslint-disable-next-line flowtype/no-weak-types\ntype ExternalQueryResultRowType = Object;\n\nexport type QueryAnyFirstFunctionType = QueryMethodType<$ReadOnlyArray<ExternalQueryResultRowColumnType>>;\nexport type QueryAnyFunctionType = QueryMethodType<$ReadOnlyArray<ExternalQueryResultRowType>>;\nexport type QueryFunctionType = QueryMethodType<ExternalQueryResultRowType>;\nexport type QueryManyFirstFunctionType = QueryMethodType<$ReadOnlyArray<ExternalQueryResultRowColumnType>>;\nexport type QueryManyFunctionType = QueryMethodType<$ReadOnlyArray<ExternalQueryResultRowType>>;\nexport type QueryMaybeOneFirstFunctionType = QueryMethodType<ExternalQueryResultRowColumnType>;\nexport type QueryMaybeOneFunctionType = QueryMethodType<ExternalQueryResultRowType | null>;\nexport type QueryOneFirstFunctionType = QueryMethodType<ExternalQueryResultRowColumnType>;\nexport type QueryOneFunctionType = QueryMethodType<ExternalQueryResultRowType>;\n\nexport type InterceptorType = {|\n  +afterPoolConnection?: (\n    connectionContext: ConnectionContextType,\n    connection: DatabasePoolConnectionType\n  ) => MaybePromiseType<void>,\n  +afterQueryExecution?: (\n    queryContext: QueryContextType,\n    query: QueryType,\n    result: QueryResultType<QueryResultRowType>\n  ) => MaybePromiseType<QueryResultType<QueryResultRowType>>,\n  +beforePoolConnection?: (\n    connectionContext: PoolContextType\n  ) => MaybePromiseType<?DatabasePoolType>,\n  +beforePoolConnectionRelease?: (\n    connectionContext: ConnectionContextType,\n    connection: DatabasePoolConnectionType\n  ) => MaybePromiseType<void>,\n  +beforeQueryExecution?: (\n    queryContext: QueryContextType,\n    query: QueryType\n  ) => MaybePromiseType<QueryResultType<QueryResultRowType> | void>,\n  +transformQuery?: (\n    queryContext: QueryContextType,\n    query: QueryType\n  ) => QueryType,\n  +transformRow?: (\n    queryContext: QueryContextType,\n    query: QueryType,\n    row: QueryResultRowType,\n    fields: $ReadOnlyArray<FieldType>\n  ) => QueryResultRowType\n|};\n"],"file":"types.js"}