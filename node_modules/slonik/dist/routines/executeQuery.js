"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _serializeError = _interopRequireDefault(require("serialize-error"));

var _getStackTrace = require("get-stack-trace");

var _utilities = require("../utilities");

var _errors = require("../errors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line complexity
const executeQuery = async (connectionLogger, connection, clientConfiguration, rawSql, values, inheritedQueryId, executionRoutine) => {
  if (connection.connection.slonik.terminated) {
    throw new _errors.UnexpectedStateError('Cannot use terminated connection.');
  }

  const queryInputTime = process.hrtime.bigint();
  let stackTrace = null;

  if (clientConfiguration.captureStackTrace) {
    const callSites = await (0, _getStackTrace.getStackTrace)();
    stackTrace = callSites.map(callSite => {
      return {
        columnNumber: callSite.columnNumber,
        fileName: callSite.fileName,
        lineNumber: callSite.lineNumber
      };
    });
  }

  const queryId = inheritedQueryId || (0, _utilities.createQueryId)();
  const log = connectionLogger.child({
    queryId
  });
  const originalQuery = {
    sql: rawSql,
    values
  };
  let actualQuery = { ...originalQuery
  };
  const executionContext = {
    connectionId: connection.connection.slonik.connectionId,
    log,
    originalQuery,
    poolId: connection.connection.slonik.poolId,
    queryId,
    queryInputTime,
    stackTrace,
    transactionId: connection.connection.slonik.transactionId
  };

  for (const interceptor of clientConfiguration.interceptors) {
    if (interceptor.transformQuery) {
      actualQuery = interceptor.transformQuery(executionContext, actualQuery);
    }
  }

  let result;

  for (const interceptor of clientConfiguration.interceptors) {
    if (interceptor.beforeQueryExecution) {
      result = await interceptor.beforeQueryExecution(executionContext, actualQuery);

      if (result) {
        return result;
      }
    }
  }

  const notices = [];

  const noticeListener = notice => {
    notices.push(notice);
  };

  connection.on('notice', noticeListener);

  try {
    result = await executionRoutine(connection, actualQuery.sql, actualQuery.values, executionContext, actualQuery);
  } catch (error) {
    // 'Connection terminated' refers to node-postgres error.
    // @see https://github.com/brianc/node-postgres/blob/eb076db5d47a29c19d3212feac26cd7b6d257a95/lib/client.js#L199
    if (error.code === '57P01' || error.message === 'Connection terminated') {
      connection.connection.slonik.terminated = true;
      throw new _errors.BackendTerminatedError();
    }

    if (error.code === '57014') {
      throw new _errors.QueryCancelledError();
    }

    log.error({
      error: (0, _serializeError.default)(error),
      queryId
    }, 'query produced an error');

    if (error.code === '23502') {
      throw new _errors.NotNullIntegrityConstraintViolationError(error.constraint);
    }

    if (error.code === '23503') {
      throw new _errors.ForeignKeyIntegrityConstraintViolationError(error.constraint);
    }

    if (error.code === '23505') {
      throw new _errors.UniqueIntegrityConstraintViolationError(error.constraint);
    }

    if (error.code === '23514') {
      throw new _errors.CheckIntegrityConstraintViolationError(error.constraint);
    }

    throw error;
  } finally {
    connection.off('notice', noticeListener);
  }

  result.notices = notices;

  for (const interceptor of clientConfiguration.interceptors) {
    if (interceptor.afterQueryExecution) {
      result = await interceptor.afterQueryExecution(executionContext, actualQuery, result);
    }
  } // Stream does not have `rows` in the result object and all rows are already transformed.


  if (result.rows) {
    for (const interceptor of clientConfiguration.interceptors) {
      if (interceptor.transformRow) {
        const transformRow = interceptor.transformRow;
        const fields = result.fields; // eslint-disable-next-line no-loop-func

        const rows = result.rows.map(row => {
          return transformRow(executionContext, actualQuery, row, fields);
        });
        result = { ...result,
          rows
        };
      }
    }
  }

  return result;
};

var _default = executeQuery;
exports.default = _default;
//# sourceMappingURL=executeQuery.js.map