{"version":3,"sources":["../../src/routines/setupTypeParsers.js"],"names":["connection","typeParsers","length","typeNames","map","typeParser","name","postgresTypes","query","rows","types","TypeOverrides","postgresType","find","maybeTargetPostgresType","typname","Error","setTypeParser","oid","value","parse","typarray","arrayParser","create","_types"],"mappings":";;;;;;;AAEA;;AAGA;;;;gCAMsBA,U,EAA4CC,W,KAAgD;AAChH,MAAIA,WAAW,CAACC,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B,WAAO,IAAP;AACD;;AAED,QAAMC,SAAS,GAAGF,WAAW,CAACG,GAAZ,CAAiBC,UAAD,IAAgB;AAChD,WAAOA,UAAU,CAACC,IAAlB;AACD,GAFiB,CAAlB;AAIA,QAAMC,aAAa,GAAG,CACpB,MAAMP,UAAU,CAACQ,KAAX,CAAiB,4EAAjB,EAA+F,CACnGL,SADmG,CAA/F,CADc,EAIpBM,IAJF;AAMA,QAAMC,KAAK,GAAG,IAAIC,sBAAJ,EAAd;;AAEA,OAAK,MAAMN,UAAX,IAAyBJ,WAAzB,EAAsC;AACpC,UAAMW,YAAY,GAAGL,aAAa,CAACM,IAAd,CAAoBC,uBAAD,IAA6B;AACnE,aAAOA,uBAAuB,CAACC,OAAxB,KAAoCV,UAAU,CAACC,IAAtD;AACD,KAFoB,CAArB;;AAIA,QAAI,CAACM,YAAL,EAAmB;AACjB,YAAM,IAAII,KAAJ,CAAU,oBAAoBX,UAAU,CAACC,IAA/B,GAAsC,cAAhD,CAAN;AACD;;AAEDI,IAAAA,KAAK,CAACO,aAAN,CAAoBL,YAAY,CAACM,GAAjC,EAAuCC,KAAD,IAAW;AAC/C,aAAOd,UAAU,CAACe,KAAX,CAAiBD,KAAjB,CAAP;AACD,KAFD;;AAIA,QAAIP,YAAY,CAACS,QAAjB,EAA2B;AACzBX,MAAAA,KAAK,CAACO,aAAN,CAAoBL,YAAY,CAACS,QAAjC,EAA4CF,KAAD,IAAW;AACpD,eAAOG,qBACJC,MADI,CAEHJ,KAFG,EAGHd,UAAU,CAACe,KAHR,EAKJA,KALI,EAAP;AAMD,OAPD;AAQD;AACF,GAxC+G,CA0ChH;;;AACApB,EAAAA,UAAU,CAACwB,MAAX,GAAoBd,KAApB;AAEA,SAAO,IAAP;AACD,C","sourcesContent":["// @flow\n\nimport {\n  arrayParser\n} from 'pg-types';\nimport TypeOverrides from 'pg/lib/type-overrides';\nimport type {\n  InternalDatabaseConnectionType,\n  TypeParserType\n} from '../types';\n\nexport default async (connection: InternalDatabaseConnectionType, typeParsers: $ReadOnlyArray<TypeParserType>) => {\n  if (typeParsers.length === 0) {\n    return null;\n  }\n\n  const typeNames = typeParsers.map((typeParser) => {\n    return typeParser.name;\n  });\n\n  const postgresTypes = (\n    await connection.query('SELECT oid, typarray, typname FROM pg_type WHERE typname = ANY($1::text[])', [\n      typeNames\n    ])\n  ).rows;\n\n  const types = new TypeOverrides();\n\n  for (const typeParser of typeParsers) {\n    const postgresType = postgresTypes.find((maybeTargetPostgresType) => {\n      return maybeTargetPostgresType.typname === typeParser.name;\n    });\n\n    if (!postgresType) {\n      throw new Error('Database type \"' + typeParser.name + '\" not found.');\n    }\n\n    types.setTypeParser(postgresType.oid, (value) => {\n      return typeParser.parse(value);\n    });\n\n    if (postgresType.typarray) {\n      types.setTypeParser(postgresType.typarray, (value) => {\n        return arrayParser\n          .create(\n            value,\n            typeParser.parse\n          )\n          .parse();\n      });\n    }\n  }\n\n  // eslint-disable-next-line id-match\n  connection._types = types;\n\n  return null;\n};\n"],"file":"setupTypeParsers.js"}