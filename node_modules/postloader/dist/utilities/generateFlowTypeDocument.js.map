{"version":3,"sources":["../../src/utilities/generateFlowTypeDocument.js"],"names":["generateFlowTypeDeclarationBody","columns","dataTypeMap","sortedColumns","propertyDeclarations","column","propertyDataType","dataType","push","name","isNullable","join","unnormalisedColumns","map","mappedTableName","tableName","tableNames","filter","index","self","indexOf","typeDeclarations","tableColumns","typeName","typeDeclaration","split","sort","exportedTypes"],"mappings":";;;;;;;AAEA;;AAOA;;AACA;;AACA;;;;;;;;AAEA,MAAMA,+BAA+B,GAAG,CAACC,OAAD,EAAsCC,WAA4B,GAAG,EAArE,KAAoF;AAC1H,QAAMC,aAAa,GAAG,oBAAOF,OAAP,EAAgB,aAAhB,CAAtB;AAEA,QAAMG,oBAAoB,GAAG,EAA7B;;AAEA,OAAK,MAAMC,MAAX,IAAqBF,aAArB,EAAoC;AAClC,UAAMG,gBAAgB,GAAGJ,WAAW,CAACG,MAAM,CAACE,QAAR,CAAX,GAA+B,0BAAYL,WAAW,CAACG,MAAM,CAACE,QAAR,CAAvB,CAA/B,GAA2E,0BAAYF,MAAM,CAACE,QAAnB,CAApG;AAEAH,IAAAA,oBAAoB,CAACI,IAArB,CAA0B,MAAM,iCAAmBH,MAAM,CAACI,IAA1B,CAAN,GAAwC,IAAxC,GAA+CH,gBAA/C,IAAmED,MAAM,CAACK,UAAP,GAAoB,SAApB,GAAgC,EAAnG,CAA1B;AACD;;AAED,SAAON,oBAAoB,CAACO,IAArB,CAA0B,IAA1B,CAAP;AACD,CAZD;;eAce,CAACC,mBAAD,EAAkDV,WAA4B,GAAG,EAAjF,KAAgG;AAC7G,QAAMD,OAAO,GAAGW,mBAAmB,CAChCC,GADa,CACRR,MAAD,IAAY;AACf,6BACKA,MADL;AAEES,MAAAA,eAAe,EAAET,MAAM,CAACS,eAAP,IAA0BT,MAAM,CAACU;AAFpD;AAID,GANa,CAAhB;AAQA,QAAMC,UAAU,GAAGf,OAAO,CACvBY,GADgB,CACXR,MAAD,IAAY;AACf,WAAOA,MAAM,CAACS,eAAP,IAA0BT,MAAM,CAACU,SAAxC;AACD,GAHgB,EAIhBE,MAJgB,CAIT,CAACF,SAAD,EAAYG,KAAZ,EAAmBC,IAAnB,KAA4B;AAClC,WAAOA,IAAI,CAACC,OAAL,CAAaL,SAAb,MAA4BG,KAAnC;AACD,GANgB,CAAnB;AAQA,QAAMG,gBAAgB,GAAG,EAAzB;;AAEA,OAAK,MAAMN,SAAX,IAAwBC,UAAxB,EAAoC;AAClC,UAAMM,YAAY,GAAGrB,OAAO,CAACgB,MAAR,CAAgBZ,MAAD,IAAY;AAC9C,aAAOA,MAAM,CAACS,eAAP,KAA2BC,SAAlC;AACD,KAFoB,CAArB;AAIA,UAAMQ,QAAQ,GAAG,6BAAeR,SAAf,CAAjB;AAEA,UAAMS,eAAe,GAAI;OACtBD,QAAS;IACZvB,+BAA+B,CAACsB,YAAD,EAAepB,WAAf,CAA/B,CAA2DuB,KAA3D,CAAiE,IAAjE,EAAuEC,IAAvE,GAA8Ef,IAA9E,CAAmF,OAAnF,CAA4F;IAF5F;AAKAU,IAAAA,gBAAgB,CAACb,IAAjB,CAAsBgB,eAAtB;AACD;;AAED,QAAMG,aAAa,GAAGX,UAAU,CAACH,GAAX,CAAgBE,SAAD,IAAe;AAClD,WAAO,6BAAeA,SAAf,CAAP;AACD,GAFqB,EAGnBW,IAHmB,GAInBf,IAJmB,CAId,OAJc,CAAtB;AAMA,SAAOU,gBAAgB,CAACV,IAAjB,CAAsB,IAAtB,IAA+B;;IAEpCgB,aAAc;GAFhB;AAID,C","sourcesContent":["// @flow\n\nimport {\n  sortBy\n} from 'lodash';\nimport type {\n  ColumnType,\n  DataTypeMapType\n} from '../types';\nimport getFlowType from './getFlowType';\nimport formatTypeName from './formatTypeName';\nimport formatPropertyName from './formatPropertyName';\n\nconst generateFlowTypeDeclarationBody = (columns: $ReadOnlyArray<ColumnType>, dataTypeMap: DataTypeMapType = {}): string => {\n  const sortedColumns = sortBy(columns, 'column_name');\n\n  const propertyDeclarations = [];\n\n  for (const column of sortedColumns) {\n    const propertyDataType = dataTypeMap[column.dataType] ? getFlowType(dataTypeMap[column.dataType]) : getFlowType(column.dataType);\n\n    propertyDeclarations.push('+' + formatPropertyName(column.name) + ': ' + propertyDataType + (column.isNullable ? ' | null' : ''));\n  }\n\n  return propertyDeclarations.join('\\n');\n};\n\nexport default (unnormalisedColumns: $ReadOnlyArray<ColumnType>, dataTypeMap: DataTypeMapType = {}): string => {\n  const columns = unnormalisedColumns\n    .map((column) => {\n      return {\n        ...column,\n        mappedTableName: column.mappedTableName || column.tableName\n      };\n    });\n\n  const tableNames = columns\n    .map((column) => {\n      return column.mappedTableName || column.tableName;\n    })\n    .filter((tableName, index, self) => {\n      return self.indexOf(tableName) === index;\n    });\n\n  const typeDeclarations = [];\n\n  for (const tableName of tableNames) {\n    const tableColumns = columns.filter((column) => {\n      return column.mappedTableName === tableName;\n    });\n\n    const typeName = formatTypeName(tableName);\n\n    const typeDeclaration = `\ntype ${typeName} = {|\n  ${generateFlowTypeDeclarationBody(tableColumns, dataTypeMap).split('\\n').sort().join(',\\n  ')}\n|};`;\n\n    typeDeclarations.push(typeDeclaration);\n  }\n\n  const exportedTypes = tableNames.map((tableName) => {\n    return formatTypeName(tableName);\n  })\n    .sort()\n    .join(',\\n  ');\n\n  return typeDeclarations.join('\\n') + `\\n\nexport type {\n  ${exportedTypes}\n};`;\n};\n"],"file":"generateFlowTypeDocument.js"}