"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handler = exports.builder = exports.desc = exports.command = void 0;

var _slonik = require("slonik");

var _queries = require("../../queries");

var _utilities = require("../../utilities");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const command = 'generate-loaders';
exports.command = command;
const desc = '';
exports.desc = desc;

const builder = yargs => {
  yargs.options({
    'column-filter': {
      description: 'Function used to filter columns. Function is constructed using `new Function`. Function receives table name as the first parameter, column name as the second parameter and all database columns as the third parameter (parameter names are "tableName", "columnName" and "columns").',
      type: 'string'
    },
    'data-type-map': {
      description: 'A JSON string describing an object mapping user-defined database types to Flow types, e.g. {"email": "string"}',
      type: 'string'
    },
    'database-connection-uri': {
      demand: true
    },
    'table-name-mapper': {
      description: 'Function used to map table names. Function is constructed using `new Function`. Function receives table name as the first parameter and all database columns as the second parameter (parameter names are "tableName" and "columns").',
      type: 'string'
    }
  });
};

exports.builder = builder;

const handler = async argv => {
  // eslint-disable-next-line no-extra-parens, no-new-func
  const filterColumn = argv.columnFilter ? new Function('tableName', 'columnName', 'columns', argv.columnFilter) : null; // eslint-disable-next-line no-extra-parens, no-new-func

  const mapTableName = argv.tableNameMapper ? new Function('tableName', 'columns', argv.tableNameMapper) : null;
  const dataTypeMap = argv.dataTypeMap ? JSON.parse(argv.dataTypeMap) : {};
  const pool = await (0, _slonik.createPool)(argv.databaseConnectionUri);
  const columns = await (0, _queries.getDatabaseColumns)(pool);
  const normalizedColumns = columns.filter(column => {
    if (!filterColumn) {
      return true;
    }

    return filterColumn(column.tableName, column.name, columns);
  }).map(column => {
    return _objectSpread({}, column, {
      isNullable: column.comment && column.comment.includes('POSTLOAD_NOTNULL') ? false : column.isNullable
    });
  }).map(column => {
    if (!mapTableName) {
      return column;
    }

    return _objectSpread({}, column, {
      mappedTableName: mapTableName(column.tableName, columns)
    });
  });
  const indexes = await (0, _queries.getDatabaseIndexes)(pool); // eslint-disable-next-line no-console

  console.log((0, _utilities.generateDataLoaderFactory)(normalizedColumns, indexes, dataTypeMap));
};

exports.handler = handler;
//# sourceMappingURL=generate-loaders.js.map